Solution 1:By using LTSA to model the Java implementation of solution 1 in FSP, one deadlock was found. The deadlock is traced when one tagged bike is transmitting by robot or inspecting by inspector, while the other tagged bike has been sensed by sensor hence needs robot and inspector. This problem is same as I discussed in assignment 1a for solution 1, while in Java implementation adjust sleep times of each threads leads to different results, so it is not easy to simulate the deadlock in short time. Fortunately, LTSA has a function ‘check safety’ which can trace terminal set of states that results in deadlock quickly. The simulation result shows same thing as I expected. On the aspect of safety and liveness properties, since this model is designed to have deadlock on purpose, it is quite meaningless to set safety properties. However, safety of robot and inspector processes still need check, hence two properties named SAFE_ROBOT and SAFE_INSP are designed. SAFE_ROBOT ensures that after ‘pickup’ action is observed, ‘set_insp_busy’ and ‘inspect’ actions should occur before other actions. SAFE_INSP property is similar, it ensures ‘set_insp_free’ and ‘putbike_to_belt’ actions occur after action ‘return’ happens. Solution 2:In Java design, solution 2 transmits inspected bikes to another short belt, this avoids the transmit collision of uninspected bikes and inspected bikes. Therefore, in LTSA, a process named ‘BELTS’ is created to simulate the short belt, and working with the long belt process concurrently. In addition, a set of priority actions are added so that ‘removeTag’ and ‘return’ have higher priority than all other actions. The running result shows no deadlocks or errors traced, and also no progress violations detected, which proves that my design is correct. Furthermore, two same safety properties as solution 1 are used to test the program and the result is also positive. 

In conclusion, no extra problems were found.

// Name: Hongyao Wei
// ID: 741027