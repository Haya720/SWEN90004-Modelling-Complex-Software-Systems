Solution 1:The requirements for solution 1 are: build a sensor on segment 3 of belt which always testing bicycle on it, if the sensor finds out the bicycle has tag, then it should call robot to move this tagged bicycle to the inspector, after receive the tagged bicycle, inspector starts to inspect it to see whether it is defective or not, if the bicycle is non defective, then remove the tag on bicycle, otherwise keep the tag, the next step is call robot to return the inspected bicycle to belt when segment 3 is available, if segment 3 has bicycle on it, then the robot should hold the inspected bicycle until segment 3 is empty. In my implementation, only robot and inspector are thread, sensor is not. Moreover, three flags are created to control movement of robot. The first flag is on bicycle, each bicycle is initialized as ‘not checked’ by setting an attribute named ‘checkFlag’ as false, after inspector decides whether remove its tag, this flag will change to true, so when this inspected bicycle moved back to belt, the sensor will not check it again which avoids chaos. The other flag is on inspector, an attribute named ‘inspectorBusy’ is initialized as false to indicate the inspector has no bicycle to inspect, once get tagged bicycle from robot, this flag will change to true, and change back to false after pass inspected bicycle to robot. The last flag ‘belt3empty’ is true if no bicycle on the segment 3 of belt. 
Hence, the robot can transfer tagged bicycle from belt to inspector if the latter is not busy, and it can move inspected bicycle back to belt if segment 3 is empty, otherwise the robot should hold bicycle until the belt is available. Therefore, this design has one potential problem: if the robot wants to move inspected bicycle back to belt while there is another tagged bicycle on segment 3 waiting for robot to transmit it to inspector, this makes both sides cannot act, which cause a deadlock. Fortunately, this issue is solved by solution 2.Solution 2:The fundamental requirements for solution 2 is same as solution 1, the only difference is each inspected bicycle will be moved to another short belt instead of the original one. Hence, in solution 2, two belts are created to transmit bicycles, in the end, two consumers wait to take off bicycles from two belts. The constructor of class Robot has three arguments: two for two belts, and one for inspector. This version of design works fine and better than solution 1.